if(y < 0){
print("Error: exponent is negative")
}
power_of_error <- function(x, y){
if(y < 0){
stop("Error: exponent is negative")
}
Z = x^y
print(Z)
}
power_of(2, y = -1)
power_of_error <- function(x, y){
Z = x^y
print(Z)
if(y < 0){
print("Error: exponent is negative")
}
}
power_of_error(2, y = -1)
power_of_error <- function(x, y){
if(y < 0){
stop("Error: exponent is negative")
}
Z = x^y
print(Z)
}
power_of_error(2, y = -1)
power_of_error <- function(x, y){
if(y < 0){
warning("Error: exponent is negative")
}
Z = x^y
print(Z)
}
power_of_error(2, y = -1)
power_of_error <- function(x, y){
if(y < 0){
warning("Exponent is negative")
}
Z = x^y
print(Z)
}
power_of_error(2, y = -1)
power_of_error(2, y = -200)
power_of_error <- function(x, y){
if(y < 0){
stop("Exponent is negative")
}
Z = x^y
print(Z)
}
power_of_error(2, y = -200)
#### Sample function ####
A
sample(A, size = 25)
sample(A, size = 25)
B <- sample(A, size = 25)
B
power_of_error <- function(x, y){
if(y < 0){
warning("Exponent is negative")
}
Z = x^y
print(Z)
}
power_of_error(2, y = -200)
w <- power_of_error(2, y = -200)
w
power_of_error <- function(x, y){
if(y < 0){
warning("Exponent is negative")
}
Z = x^y
return(Z)
}
w <- power_of_error(2, y = -2)
w
Multiplication <- function(x, y) {
z <- x*y
return(z)
}
Multiplication(x = 3, y = 5)
Divide <- function(x, y) {
z <- x/y
return(z)
}
Divice(x = 15, y = 3)
Divide(x = 15, y = 3)
Divide(x = 15, y = 3)
Divide(15, 3)
Divide(3, 15)
Divide(x = 3, y = 15)
Divide(y = 3, x = 15)
Divide(y = 3, 15)
Divide <- function(x, y, z = 1) {
z <- (x*z)/y
return(z)
}
Divide(x = 15, y = 3)
Divide(15, 3)
Divide(3, 15)
Divide(x = 3, y = 15)
Divide(y = 3, x = 15)
Divide(y = 3, 15)
Divide(z = 2, 15, 3)
Divide(z = 2, y = 15, x = 3)
power_of <- function(x, y = 1) {
z <- x^y
return(z)
}
power_of(434)
power_of <- function(x, y = 0) {
z <- x^y
return(z)
}
power_of(434)
power_of(x = 35)
power_of(x = 42)
power_of(x = 2, 2)
power_of(x = 2, 3)
power_of(x = 2, 4)
#### Load packages ####
library(rgdal)
library(sp)
library(tidyverse)
?read.delim
#### Read Data ####
occurrences <- read.delim("Python_bivittatus/occurrence.txt")
View(occurrences)
Florida <- readOGR("Florida_State_Waters_and_Land_Boundary-shp", "Florida_State_Waters_and_Land_Boundary")
plot(Florida)
getwd()
Florida <- readOGR("Florida_State_Waters_and_Land_Boundary-shp/Florida_State_Waters_and_Land_Boundary.shp")
plot(Florida)
# Extracts species name, year, and coordinates
occurrences <- occurrences[, c(230, 103, 133, 134)]
View(occurrences)
View(occurrences)
head(occurrences)
head(occurrences, 10)
head(occurrences, 15)
head(occurrences, 10)
?head
head(occurrences)
tail(occurrences)
# Retain full records, without NAs #
occurrences <- occurrences[complete.cases(occurrences), ]
# Frequency table of occurrences per year #
occurrences$year
table(occurrences$year)
# Transform into spatial points object with year as attribute #
occurrences <- SpatialPointsDataFrame(coords = occurrences[, 4:3], data = occurrences[, 1:2])
# Plotting all the data first #
plot(Florida)
points(occurrences)
?points
points(occurrences, col = "blue")
points(occurrences, col = "blue", pch = "x")
points(occurrences, col = "blue", pch = 5)
# Plotting all the data first #
plot(Florida)
points(occurrences, col = "blue", pch = 19)
# Plotting all the data first #
plot(Florida)
points(occurrences, col = "blue", pch = 21)
# Plotting all the data first #
plot(Florida)
points(occurrences, col = "blue", pch = "x")
points(occurrences, col = "red", pch = "x")
# Available years
occurrences$year
# Available years
unique(occurrences$year)
# Available years
sort(unique(occurrences$year))
# Available years
sort(unique(occurrences$year), decreasing = TRUE)
# Available years
x <- occurrences$year
y <- unique(x)
sort(y)
sort(unique(occurrences$year))
# Plotting just one year #
occurrences$year
occurrences$year == 1991
# Frequency table of occurrences per year #
table(occurrences$year)
occurrences$year == 2013
plot(Florida, main = 1991)
points(occurrences[occurrences$year == 1991, ], col = "red", pch = "x")
plot(Florida, main = 2013)
points(occurrences[occurrences$year == 2013, ], col = "red", pch = "x")
table(occurrences$year)
plot(Florida, main = 2020)
points(occurrences[occurrences$year == 2020, ], col = "red", pch = "x")
plot(Florida, main = 2019)
points(occurrences[occurrences$year == 2019, ], col = "red", pch = "x")
sort(unique(occurrences$year))
sort(unique(occurrences$year))[1]
sort(unique(occurrences$year))[2]
sort(unique(occurrences$year))[19]
# Plotting just one year #
plot(Florida, main = sort(unique(occurrences$year))[19])
points(occurrences[occurrences$year == sort(unique(occurrences$year))[19], ], col = "red")
for(i in 1:10) {
print(i)
}
for(i in unique(occurrences$year)) {
print(i)
}
for(i in sort(unique(occurrences$year))) {
print(i)
}
for(i in sort(unique(occurrences$year))) {
plot(Florida, main = i)
points(occurrences[occurrences$year == i, ], col = "red")
print(i)
}
1:length(unique(occurrences$year))
for(i in 1:length(unique(occurrences$year))) {
plot(Florida, main = sort(unique(occurrences$year))[i])
points(occurrences[occurrences$year == sort(unique(occurrences$year))[i], ], col = "red")
}
########## Create your function below ##############
map_years <- function(state, occurrenceDF) {
#Internal process
# Extracts species name, year, and coordinates
occurrences <- occurrenceDF[, c(230, 103, 133, 134)]
# Retain full records, without NAs #
occurrences <- occurrences[complete.cases(occurrences), ]
# Transform into spatial points object with year as attribute #
occurrences <- SpatialPointsDataFrame(coords = occurrences[, 4:3], data = occurrences[, 1:2])
# For Loop
for(i in 1:length(unique(occurrences$year))) {
plot(state, main = sort(unique(occurrences$year))[i])
points(occurrences[occurrences$year == sort(unique(occurrences$year))[i], ], col = "red")
}
}
#### Read Data ####
occurrences <- read.delim("Python_bivittatus/occurrence.txt")
Florida <- readOGR("Florida_State_Waters_and_Land_Boundary-shp", "Florida_State_Waters_and_Land_Boundary")
#### Read Data ####
pbivitattus <- read.delim("Python_bivittatus/occurrence.txt")
map_years(state = Florida, occurrenceDF = pbivittatus)
#### Read Data ####
pbivitattus <- read.delim("Python_bivittatus/occurrence.txt")
map_years(state = Florida, occurrenceDF = pbivitattus)
# For Loop
for(i in 1:length(unique(occurrences$year))) {
plot(state, main = sort(unique(occurrences$year))[i])
points(occurrences[occurrences$year == sort(unique(occurrences$year))[i], ], col = "red")
print(i)
}
########## Create your function below ##############
map_years <- function(state, occurrenceDF) {
#Internal process
# Extracts species name, year, and coordinates
occurrences <- occurrenceDF[, c(230, 103, 133, 134)]
# Retain full records, without NAs #
occurrences <- occurrences[complete.cases(occurrences), ]
# Transform into spatial points object with year as attribute #
occurrences <- SpatialPointsDataFrame(coords = occurrences[, 4:3], data = occurrences[, 1:2])
# For Loop
for(i in 1:length(unique(occurrences$year))) {
plot(state, main = sort(unique(occurrences$year))[i])
points(occurrences[occurrences$year == sort(unique(occurrences$year))[i], ], col = "red")
print(i)
}
}
tmanatus <- pbivitattus <- read.delim("Trichechus_manatus//occurrence.txt")
########## Create your function below ##############
map_years <- function(state, occurrenceDF) {
#Internal process
# Extracts species name, year, and coordinates
occurrences <- occurrenceDF[, c(230, 103, 133, 134)]
# Retain full records, without NAs #
occurrences <- occurrences[complete.cases(occurrences), ]
# Transform into spatial points object with year as attribute #
occurrences <- SpatialPointsDataFrame(coords = occurrences[, 4:3], data = occurrences[, 1:2])
# For Loop
for(i in 1:length(unique(occurrences$year))) {
plot(state, main = sort(unique(occurrences$year))[i])
points(occurrences[occurrences$year == sort(unique(occurrences$year))[i], ], col = "red")
print(i)
}
}
# Coin Toss Example
# Simulate a coin toss
coin_toss <- rbinom(n = 1, size = 1, prob = 0.5)
# Set condition for success, define process to occur if conditions
# are TRUE or FALSE and corresponding outputs
if(coin_toss == 1) {
print("You win")
} else {
print("You Lose")
}
# Simulate a coin toss
coin_toss <- rbinom(n = 1, size = 1, prob = 0.7)
# Set condition for success, define process to occur if conditions
# are TRUE or FALSE and corresponding outputs
if(coin_toss == 1) {
print("Heads")
} else {
print("Tails")
}
# You can change the values of X and Y if you want
x <- 5; y <- 8
x > y #is x greater than y? Results to FALSE
x < y #is x less than y? Results to TRUE
x >= y #is x equal to or greater than y? Results to FALSE
x <= y #is x equal to or less than y? Results to TRUE
x == y #is x equal to y? Results to FALSE
x != y #is x different to y? Results to TRUE
x %in% y #is the value of x contained in the values of y? Results FALSE
# You can change the values of X and Y if you want
x <- c(F, F, F); y <- c(F, F, T)
identical(x, y) #if two objects are exactly the same returns one TRUE
any(x) #Input is a logical vector, if any value is TRUE, returns one TRUE
any(y)
all(y) # input is a logical vector, if all values are TRUE, returns one TRUE
##### is.() #Family of functions
is.numeric(x) # if vector or matrix is numeric, returns TRUE
is.integer(y) # if vector or matrix is integer, returns TRUE
is.vector(x) # if object is vector, returns TRUE, etcâ€¦
is.logical(x)
# Load Maze Functions
source("Maze_functions.R")
rbinom(n, size = 1, prob = 0.36)
n = 1
rbinom(n, size = 1, prob = 0.36)
rm(n)
client <- function() {
if(rbinom(1, size = 1, prob = 0.36) == 1) {
person <- "Lactose Intolerant"
} else {
person <- "Non-Lactose Intolerant"
}
}
client <- function() {
if(rbinom(1, size = 1, prob = 0.36) == 1) {
person <- "Lactose Intolerant"
} else {
person <- "Non-Lactose Intolerant"
}
person
}
client()
client()
client()
client()
client()
client()
client()
client()
client()
client()
client()
client()
client()
client()
client()
client()
client()
client()
###################################################################
################## Exercise 2: Vending Machine ####################
###################################################################
source("Vending_Machine_Clients.R")
client()
# Function representing multiple clients on the Vending Machine
lapply(1:10, client_arrives)
# Function representing ONE client on the Vending Machine
client_arrives <- function() {
if(rbinom(1, size = 1, prob = 0.36) == 1) {
person <- "Lactose Intolerant"
} else {
person <- "Non-Lactose Intolerant"
}
person
}
# Function representing multiple clients on the Vending Machine
lapply(1:10, client_arrives)
# Function representing multiple clients on the Vending Machine
clients <- NULL
for(i in 1:10) {
clients[i] <- client_arrives()
}
clients
# Function representing multiple clients on the Vending Machine
clients <- function(x = 10) {
clients <- NULL
for(i in 1:10) {
clients[i] <- client_arrives()
}
}
# Function representing multiple clients on the Vending Machine
clients_line <- function(x = 10) {
clients <- NULL
for(i in 1:10) {
clients[i] <- client_arrives()
}
clients
}
clients_line()
# Function representing ONE client on the Vending Machine
client_arrives <- function() {
if(rbinom(1, size = 1, prob = 0.36) == 1) {
person <- "Lactose Intolerant"
} else {
person <- "Non-Lactose Intolerant"
}
person
}
# Function representing multiple clients on the Vending Machine
clients_line <- function(x = 10) {
clients <- NULL
for(i in 1:10) {
clients[i] <- client_arrives()
}
clients
}
for(i in 1:x) {
clients[i] <- client_arrives()
}
# Function representing multiple clients on the Vending Machine
clients_line <- function(x = 10) {
clients <- NULL
for(i in 1:x) {
clients[i] <- client_arrives()
}
clients
}
# Structure of a for loop #
for(i in 1:10) {
print(i)
}
#################### Quick Exercise #############################
# a) You can add a mathematical operation to the previous process
for(i in 1:10) {
print(i) # Add operation
}
# b) You can make the vector a character vector. See what happens
# Create a character vector
char_vector <- c("Alfredo", "Alejandro", "Ascanio", "Moreno") # Add character elements within "" to char_vector
for(i in char_vector) { # Substitute 1:10 for your character vector
print(i)
}
#### a) Create a for-loop for printing elements from a character vector
char_vector <- LETTERS # You can change this vector if you want
# Option 1
for(char in char_vector) {
print(char)
}
# The iterative term doesn't need to be "i" always, it can be whatever you like
#Option 2
for(i in 1:length(char_vector)) {
print(char_vector[i])
}
#### b) For-loop: mathematical operations on numeric vectors
math <- c(5, 8, 10, 13, 14, 17, 21, 24)
# Sum 2 and print the output
for(i in math){
z = i + 2
print(z)
}
# Sum 2, divide by 3, raise to the power of the original number, and print
for(i in math){
z = i + 2
z = z/3
z = z^i
print(z)
}
#### c) For-loop by factor on a biological dataset
Data <- iris # Loading the data
head(iris) # Viewing part of the data
# Create a loop to extract the mean values of Sepal and Petal Length of each flower
for(i in unique(Data$Species)){
print(mean(Data[Data$Species == i, 1]))
}
clients_line()
clients_line(100)
###############################################################################
##### Exercise 5: Build a function to sell drinks to any number of clients ####
###############################################################################
source("Vending_Machine_Clients.R")
# You can paste the folder name to your files
files <- paste("Splitted_Tmanatus/", files, sep = "")
# list.files() allows you to list all the files in a folder
files <- list.files("Splitted_Tmanatus/")
# You can paste the folder name to your files
files <- paste("Splitted_Tmanatus/", files, sep = "")
#### Create your Loop ####
full_data <- NULL
for(i in 1:length(files)){
Data <- read.csv(files[i], stringsAsFactors = FALSE)
full_data <- rbind(full_data, Data)
}
grep("WGS", Data)
grep("WGS84", Data)
grep("WGS84", as.matrix(Data))
Data$verbatimCoordinateSystem
full_data$verbatimCoordinateSystem
sum(!is.na(full_data$verbatimCoordinateSystem))
full_data$verbatimCoordinateSystem(!is.na(full_data$verbatimCoordinateSystem))
full_data$verbatimCoordinateSystem[!is.na(full_data$verbatimCoordinateSystem)]
full_data$georeferenceSources
unique(full_data$georeferenceSources)
unique(full_data$verbatimCoordinateSystem)
grep("WGS", full_data)
which(grep("WGS", full_data))
full_data[217]
names(full_data)[217]
